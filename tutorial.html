

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Tutorial &mdash; PyEnchant 3.3.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=e59714d7" />

  
      <script src="_static/jquery.js?v=5d32c60e"></script>
      <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="_static/documentation_options.js?v=3eb8911e"></script>
      <script src="_static/doctools.js?v=9bcbadda"></script>
      <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="API Listing" href="api/index.html" />
    <link rel="prev" title="Installation" href="install.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            PyEnchant
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="install.html">Installation</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Tutorial</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#basic-pyenchant-usage">Basic PyEnchant usage</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#creating-and-using-dictionary-objects">Creating and Using Dictionary Objects</a></li>
<li class="toctree-l3"><a class="reference internal" href="#personal-word-lists">Personal Word Lists</a></li>
<li class="toctree-l3"><a class="reference internal" href="#checking-entire-blocks-of-text">Checking entire blocks of text</a></li>
<li class="toctree-l3"><a class="reference internal" href="#wxspellcheckerdialog">wxSpellCheckerDialog</a></li>
<li class="toctree-l3"><a class="reference internal" href="#cmdlinechecker">CmdLineChecker</a></li>
<li class="toctree-l3"><a class="reference internal" href="#tokenization-splitting-text-into-words">Tokenization: splitting text into words</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#chunkers">Chunkers</a></li>
<li class="toctree-l4"><a class="reference internal" href="#filters">Filters</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#advanced-pyenchant-usage">Advanced PyEnchant Usage</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#providers">Providers</a></li>
<li class="toctree-l3"><a class="reference internal" href="#brokers">Brokers</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#the-default-broker">The Default Broker</a></li>
<li class="toctree-l4"><a class="reference internal" href="#provider-ordering">Provider Ordering</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#extending-enchant-tokenize">Extending enchant.tokenize</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="api/index.html">API Listing</a></li>
<li class="toctree-l1"><a class="reference internal" href="faq.html">FAQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="shootout.html">Provider Shootout</a></li>
<li class="toctree-l1"><a class="reference internal" href="changelog.html">Changelog</a></li>
<li class="toctree-l1"><a class="reference internal" href="contributing.html">Contributing to PyEnchant</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">PyEnchant</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Tutorial</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/tutorial.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="tutorial">
<h1>Tutorial<a class="headerlink" href="#tutorial" title="Link to this heading"></a></h1>
<section id="basic-pyenchant-usage">
<h2>Basic PyEnchant usage<a class="headerlink" href="#basic-pyenchant-usage" title="Link to this heading"></a></h2>
<p>Once installed, PyEnchant’s functionality is available in the “enchant” module.</p>
<section id="creating-and-using-dictionary-objects">
<h3>Creating and Using Dictionary Objects<a class="headerlink" href="#creating-and-using-dictionary-objects" title="Link to this heading"></a></h3>
<p>The most important object in the PyEnchant module is the Dict object, which represents a dictionary. These objects are used to check the spelling of words and to get suggestions for misspelled words. The following shows how to construct a simple <a class="reference internal" href="api/enchant.html#enchant.Dict" title="enchant.Dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">Dict</span></code></a> and use it to check some words:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">enchant</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">enchant</span><span class="o">.</span><span class="n">Dict</span><span class="p">(</span><span class="s2">&quot;en_US&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="s2">&quot;Hello&quot;</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="s2">&quot;Helo&quot;</span><span class="p">)</span>
<span class="go">False</span>
</pre></div>
</div>
<p>Dictionaries are created using a language tag which specifies the language to be checked - in this case, “en_US” signifies American English. If the language tag is not specified, an attempt is made to determine the language currently in use. This is not always possible, in which case an Error is raised.</p>
<p>When the current language can be determined, it operates as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">enchant</span><span class="o">.</span><span class="n">Dict</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="o">.</span><span class="n">tag</span>
<span class="go">&#39;en_AU&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">tag</span><span class="p">)</span>
<span class="go">en_AU</span>
</pre></div>
</div>
<p>Of course, this may still fail if the appropriate dictionary is not available. If it cannot be determined, the behavior is as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">enchant</span><span class="o">.</span><span class="n">Dict</span><span class="p">()</span>
<span class="gt">Traceback (most recent call last):</span>
  File <span class="nb">&quot;&lt;stdin&gt;&quot;</span>, line <span class="m">1</span>, in <span class="n">?</span>
  File <span class="nb">&quot;enchant/__init__.py&quot;</span>, line <span class="m">467</span>, in <span class="n">__init__</span>
<span class="w">    </span><span class="k">raise</span> <span class="n">Error</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
<span class="gr">enchant.Error</span>: <span class="n">No tag specified and default language could not be determined.</span>
</pre></div>
</div>
<p>There are several top-level functions in the enchant module which can be used to deal with dictionaries:</p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference internal" href="api/enchant.html#enchant.dict_exists" title="enchant.dict_exists"><code class="xref py py-func docutils literal notranslate"><span class="pre">dict_exists()</span></code></a>: Check whether a Dict is available for a given language</p></li>
<li><p><a class="reference internal" href="api/enchant.html#enchant.request_dict" title="enchant.request_dict"><code class="xref py py-func docutils literal notranslate"><span class="pre">request_dict()</span></code></a>: Construct and return a new Dict object</p></li>
<li><p><a class="reference internal" href="api/enchant.html#enchant.list_languages" title="enchant.list_languages"><code class="xref py py-func docutils literal notranslate"><span class="pre">list_languages()</span></code></a>: List the languages for which Dicts are available</p></li>
</ul>
</div></blockquote>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">enchant</span><span class="o">.</span><span class="n">dict_exists</span><span class="p">(</span><span class="s2">&quot;fake&quot;</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">enchant</span><span class="o">.</span><span class="n">dict_exists</span><span class="p">(</span><span class="s2">&quot;en_US&quot;</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">enchant</span><span class="o">.</span><span class="n">request_dict</span><span class="p">(</span><span class="s2">&quot;en_US&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span>
<span class="go">&lt;enchant.Dict object at 0x2aaaabdffa50&gt;cl</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">enchant</span><span class="o">.</span><span class="n">list_languages</span><span class="p">()</span>
<span class="go">[&#39;en&#39;, &#39;en_CA&#39;, &#39;en_GB&#39;, &#39;en_US&#39;, &#39;eo&#39;, &#39;fr&#39;, &#39;fr_CH&#39;, &#39;fr_FR&#39;]</span>
</pre></div>
</div>
<p>As shown previously, the method <a class="reference internal" href="api/enchant.html#enchant.Dict.check" title="enchant.Dict.check"><code class="xref py py-meth docutils literal notranslate"><span class="pre">check()</span></code></a> can be used to check whether a word is correctly spelled. To get suggestions for a misspelled word, use the suggest method as shown below:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="o">.</span><span class="n">suggest</span><span class="p">(</span><span class="s2">&quot;Helo&quot;</span><span class="p">)</span>
<span class="go">[&#39;He lo&#39;, &#39;He-lo&#39;, &#39;Hello&#39;, &#39;Helot&#39;, &#39;Help&#39;, &#39;Halo&#39;, &#39;Hell&#39;, &#39;Held&#39;, &#39;Helm&#39;, &#39;Hero&#39;, &quot;He&#39;ll&quot;]</span>
</pre></div>
</div>
<p>The suggestions are returned in a list, ordered from most likely replacement to least likely.</p>
<p>Once a correction is made to a miss-spelled word, it is often useful to store this correction in some way for later use. The <a class="reference internal" href="api/enchant.html#enchant.Dict" title="enchant.Dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">Dict</span></code></a> object provides several methods to handle this:</p>
<blockquote>
<div><ul class="simple">
<li><p><a class="reference internal" href="api/enchant.html#enchant.Dict.add" title="enchant.Dict.add"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add()</span></code></a>: store an unrecognised word in the user’s personal dictionary so that it is recognised as correct in the future.</p></li>
<li><p><a class="reference internal" href="api/enchant.html#enchant.Dict.remove" title="enchant.Dict.remove"><code class="xref py py-meth docutils literal notranslate"><span class="pre">remove()</span></code></a>: store a recognised word in the user’s personal exclude list, so that it is identified as an error in the future.</p></li>
<li><p><a class="reference internal" href="api/enchant.html#enchant.Dict.add_to_session" title="enchant.Dict.add_to_session"><code class="xref py py-meth docutils literal notranslate"><span class="pre">add_to_session()</span></code></a>: store an unrecognised word so that it will be recognised as correct while the Dict object is still in use.</p></li>
<li><p><a class="reference internal" href="api/enchant.html#enchant.Dict.store_replacement" title="enchant.Dict.store_replacement"><code class="xref py py-meth docutils literal notranslate"><span class="pre">store_replacement()</span></code></a>: note that one word was used to replace another, meaning that it will appear higher in the list of suggestions in the future.</p></li>
</ul>
</div></blockquote>
</section>
<section id="personal-word-lists">
<h3>Personal Word Lists<a class="headerlink" href="#personal-word-lists" title="Link to this heading"></a></h3>
<p>Dict objects can also be used to check words against a custom list of correctly-spelled words known as a Personal Word List. This is simply a file listing the words to be considered, one word per line. The following example creates a Dict object for the personal word list stored in “mywords.txt”:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pwl</span> <span class="o">=</span> <span class="n">enchant</span><span class="o">.</span><span class="n">request_pwl_dict</span><span class="p">(</span><span class="s2">&quot;mywords.txt&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>The personal word list Dict object can be used in the same way as Dict objects which reference a language dictionary. When the object’s add method is called, new entries will be appended to the bottom of the file.</p>
<p>PyEnchant also provides the class <a class="reference internal" href="api/enchant.html#enchant.DictWithPWL" title="enchant.DictWithPWL"><code class="xref py py-class docutils literal notranslate"><span class="pre">DictWithPWL</span></code></a> which can be used to combine a language dictionary and a personal word list file:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">d2</span> <span class="o">=</span> <span class="n">enchant</span><span class="o">.</span><span class="n">DictWithPWL</span><span class="p">(</span><span class="s2">&quot;en_US&quot;</span><span class="p">,</span><span class="s2">&quot;mywords.txt&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d2</span><span class="o">.</span><span class="n">check</span><span class="p">(</span><span class="s2">&quot;Hello&quot;</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</section>
<section id="checking-entire-blocks-of-text">
<h3>Checking entire blocks of text<a class="headerlink" href="#checking-entire-blocks-of-text" title="Link to this heading"></a></h3>
<p>While the <a class="reference internal" href="api/enchant.html#enchant.Dict" title="enchant.Dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">enchant.Dict</span></code></a> objects are useful for spellchecking individual words, they cannot be used directly to check, for example, an entire paragraph. The module <a class="reference internal" href="api/enchant.checker.html#module-enchant.checker" title="enchant.checker"><code class="xref py py-mod docutils literal notranslate"><span class="pre">enchant.checker</span></code></a> provides a class <a class="reference internal" href="api/enchant.checker.html#enchant.checker.SpellChecker" title="enchant.checker.SpellChecker"><code class="xref py py-class docutils literal notranslate"><span class="pre">SpellChecker</span></code></a> which is designed to handle this task.</p>
<p><cite>SpellChecker</cite> objects are created in the same way as <cite>Dict</cite> objects - by passing a language tag to the constructor. The method <a class="reference internal" href="api/enchant.checker.html#enchant.checker.SpellChecker.set_text" title="enchant.checker.SpellChecker.set_text"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_text()</span></code></a> is used to set the text which is to be checked. Once this is done, the SpellChecker object can be used as an iterator over the spelling mistakes in the text. This is best illustrated by a simple example. The following code will print out the errors encountered in a string:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">enchant.checker</span><span class="w"> </span><span class="kn">import</span> <span class="n">SpellChecker</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">chkr</span> <span class="o">=</span> <span class="n">SpellChecker</span><span class="p">(</span><span class="s2">&quot;en_US&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">chkr</span><span class="o">.</span><span class="n">set_text</span><span class="p">(</span><span class="s2">&quot;This is sme sample txt with erors.&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">err</span> <span class="ow">in</span> <span class="n">chkr</span><span class="p">:</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;ERROR:&quot;</span><span class="p">,</span> <span class="n">err</span><span class="o">.</span><span class="n">word</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">ERROR: sme</span>
<span class="go">ERROR: txt</span>
<span class="go">ERROR: erors</span>
</pre></div>
</div>
<p>The <cite>SpellChecker</cite> can use filters to ignore certain word forms, by passing a list of filters in as a keyword argument:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">enchant.checker</span><span class="w"> </span><span class="kn">import</span> <span class="n">SpellChecker</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">enchant.tokenize</span><span class="w"> </span><span class="kn">import</span> <span class="n">EmailFilter</span><span class="p">,</span> <span class="n">URLFilter</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">chkr</span> <span class="o">=</span> <span class="n">SpellChecker</span><span class="p">(</span><span class="s2">&quot;en_US&quot;</span><span class="p">,</span><span class="n">filters</span><span class="o">=</span><span class="p">[</span><span class="n">EmailFilter</span><span class="p">,</span><span class="n">URLFilter</span><span class="p">])</span>
</pre></div>
</div>
<p>The iterator paradigm can be used to implement a wide variety of spellchecking functionality. As examples of how this can be done, PyEnchant provides a wxPython-based spellchecking dialog and a command-line spellchecking program. While intended mainly as functionality demos, they are also quite useful in their own right.</p>
</section>
<section id="wxspellcheckerdialog">
<h3>wxSpellCheckerDialog<a class="headerlink" href="#wxspellcheckerdialog" title="Link to this heading"></a></h3>
<p>The module <code class="xref py py-mod docutils literal notranslate"><span class="pre">enchant.checker.wxSpellCheckerDialog</span></code> provides the class <code class="xref py py-class docutils literal notranslate"><span class="pre">wxSpellCheckerDialog</span></code> which can be used to interactively check the spelling of some text. The code below shows how to create and use such a dialog from within a wxPython application.</p>
<p>It will pop up a simple spellchecking dialog like the one shown here. Each spelling error is highlighted in turn, with the buttons offering a range of options for how to deal with the error:</p>
<blockquote>
<div><ul class="simple">
<li><p>Ignore: ignore the current occurrence of the word</p></li>
<li><p>Ignore All: ignore the current and all future occurrences of the word</p></li>
<li><p>Replace: replace the current occurrence with the corrected word</p></li>
<li><p>Replace All: replace the current and all future occurrences with the corrected word</p></li>
<li><p>Add: add the word to the user’s personal dictionary</p></li>
</ul>
</div></blockquote>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">wx</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">enchant.checker</span><span class="w"> </span><span class="kn">import</span> <span class="n">SpellChecker</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">enchant.checker.wxSpellCheckerDialog</span><span class="w"> </span><span class="kn">import</span> <span class="n">wxSpellCheckerDialog</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">app</span> <span class="o">=</span> <span class="n">wx</span><span class="o">.</span><span class="n">PySimpleApp</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">text</span> <span class="o">=</span> <span class="s2">&quot;This is sme text with a fw speling errors in it. Here are a fw more to tst it ut.&quot;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dlg</span> <span class="o">=</span> <span class="n">wxSpellCheckerDialog</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">chkr</span> <span class="o">=</span> <span class="n">SpellChecker</span><span class="p">(</span><span class="s2">&quot;en_US&quot;</span><span class="p">,</span><span class="n">text</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dlg</span><span class="o">.</span><span class="n">SetSpellChecker</span><span class="p">(</span><span class="n">chkr</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dlg</span><span class="o">.</span><span class="n">Show</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">app</span><span class="o">.</span><span class="n">MainLoop</span><span class="p">()</span>
</pre></div>
</div>
</section>
<section id="cmdlinechecker">
<h3>CmdLineChecker<a class="headerlink" href="#cmdlinechecker" title="Link to this heading"></a></h3>
<p>The module <code class="xref py py-mod docutils literal notranslate"><span class="pre">enchant.checker.CmdLineChecker</span></code> provides the class <code class="xref py py-class docutils literal notranslate"><span class="pre">CmdLineChecker</span></code> which can be used to interactively check the spelling of some text. It uses standard input and standard output to interact with the user through a command-line interface. The code below shows how to create and use this class from within a python application, along with a short sample checking session:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">enchant</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">enchant.checker</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">enchant.checker.CmdLineChecker</span><span class="w"> </span><span class="kn">import</span> <span class="n">CmdLineChecker</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">chkr</span> <span class="o">=</span> <span class="n">enchant</span><span class="o">.</span><span class="n">checker</span><span class="o">.</span><span class="n">SpellChecker</span><span class="p">(</span><span class="s2">&quot;en_US&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">chkr</span><span class="o">.</span><span class="n">set_text</span><span class="p">(</span><span class="s2">&quot;this is sme example txt&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cmdln</span> <span class="o">=</span> <span class="n">CmdLineChecker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cmdln</span><span class="o">.</span><span class="n">set_checker</span><span class="p">(</span><span class="n">chkr</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cmdln</span><span class="o">.</span><span class="n">run</span><span class="p">()</span>
<span class="go">ERROR: sme</span>
<span class="go">HOW ABOUT: [&#39;some&#39;, &#39;same&#39;, &#39;Sm&#39;, &#39;Ame&#39;, &#39;ME&#39;, &#39;Me&#39;, &#39;SE&#39;, &#39;Se&#39;, &#39;me&#39;, &#39;Esme&#39;, &#39;Mme&#39;, &#39;SSE&#39;, &#39;See&#39;, &#39;Sue&#39;, &#39;see&#39;, &#39;sue&#39;, &#39;Ste&#39;, &quot;Sm&#39;s&quot;]</span>
<span class="go">&gt;&gt; help</span>
<span class="go">0..N: replace with the numbered suggestion</span>
<span class="go">R0..rN: always replace with the numbered suggestion</span>
<span class="go">i: ignore this word</span>
<span class="go">I: always ignore this word</span>
<span class="go">a: add word to personal dictionary</span>
<span class="go">e: edit the word</span>
<span class="go">q: quit checking</span>
<span class="go">h: print this help message</span>
<span class="go">----------------------------------------------------</span>
<span class="go">HOW ABOUT: [&#39;some&#39;, &#39;same&#39;, &#39;Sm&#39;, &#39;Ame&#39;, &#39;ME&#39;, &#39;Me&#39;, &#39;SE&#39;, &#39;Se&#39;, &#39;me&#39;, &#39;Esme&#39;, &#39;Mme&#39;, &#39;SSE&#39;, &#39;See&#39;, &#39;Sue&#39;, &#39;see&#39;, &#39;sue&#39;, &#39;Ste&#39;, &quot;Sm&#39;s&quot;]</span>
<span class="go">&gt;&gt; 0</span>
<span class="go">Replacing &#39;sme&#39; with &#39;some&#39;</span>
<span class="go">ERROR: txt</span>
<span class="go">HOW ABOUT: [&#39;text&#39;, &#39;TX&#39;, &#39;ext&#39;]</span>
<span class="go">&gt;&gt; i</span>
<span class="go">DONE</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">chkr</span><span class="o">.</span><span class="n">get_text</span><span class="p">()</span>
<span class="go">&#39;this is some example txt&#39;</span>
</pre></div>
</div>
<p>As shown by this simple example, the <cite>CmdLineChecker</cite> prints each error it encounters, along with a list of suggested replacements. The user enters the desired behavior using short alphanumeric commands, as explained by the output of the ‘help’ command.</p>
</section>
<section id="tokenization-splitting-text-into-words">
<h3>Tokenization: splitting text into words<a class="headerlink" href="#tokenization-splitting-text-into-words" title="Link to this heading"></a></h3>
<p>An important task in spellchecking is splitting a body of text up into its constitutive words, each of which is then passed to a <a class="reference internal" href="api/enchant.html#enchant.Dict" title="enchant.Dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">Dict</span></code></a> object for checking. PyEnchant provides the <a class="reference internal" href="api/enchant.tokenize.html#module-enchant.tokenize" title="enchant.tokenize"><code class="xref py py-mod docutils literal notranslate"><span class="pre">enchant.tokenize</span></code></a> module to assist with this task. The purpose of this module is to provide an appropriate tokenization function which can be used to split the text. Usually, all that is required is the function <a class="reference internal" href="api/enchant.tokenize.html#enchant.tokenize.get_tokenizer" title="enchant.tokenize.get_tokenizer"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_tokenizer()</span></code></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">enchant.tokenize</span><span class="w"> </span><span class="kn">import</span> <span class="n">get_tokenizer</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tknzr</span> <span class="o">=</span> <span class="n">get_tokenizer</span><span class="p">(</span><span class="s2">&quot;en_US&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tknzr</span>
<span class="go">&lt;class enchant.tokenize.en.tokenize at 0x2aaaaab531d0&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">w</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">tknzr</span><span class="p">(</span><span class="s2">&quot;this is some simple text&quot;</span><span class="p">)]</span>
<span class="go">[(&#39;this&#39;, 0), (&#39;is&#39;, 5), (&#39;some&#39;, 8), (&#39;simple&#39;, 13), (&#39;text&#39;, 20)]</span>
</pre></div>
</div>
<p>As shown in the example above, the function <a class="reference internal" href="api/enchant.tokenize.html#enchant.tokenize.get_tokenizer" title="enchant.tokenize.get_tokenizer"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_tokenizer()</span></code></a> takes a language tag as input, and returns a tokenization class that is appropriate for that language. Instantiating this class with some text returns an iterator which will yield the words contained in that text. This is exactly the mechanism that the class <code class="xref py py-class docutils literal notranslate"><span class="pre">enchant.tokenize.SpellChecker</span></code> uses internally to split text into a series of words.</p>
<p>The items produced by the tokenizer are tuples of the form <cite>(WORD,POS)</cite> where <cite>WORD</cite> is the word which was found and <cite>POS</cite> is the position within the string at which that word begins.</p>
<section id="chunkers">
<h4>Chunkers<a class="headerlink" href="#chunkers" title="Link to this heading"></a></h4>
<p>In many applications, checkable text may be intermingled with some sort of markup (e.g. HTML tags) which does not need to be checked. To have the tokenizer return only those words that should be checked, it can be augmented with one or more chunkers.</p>
<p>A chunker is simply a special tokenizer function that breaks text up into large chunks rather than individual tokens. They are typically used by passing a list of chunkers to the function <a class="reference internal" href="api/enchant.tokenize.html#enchant.tokenize.get_tokenizer" title="enchant.tokenize.get_tokenizer"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_tokenizer()</span></code></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">enchant.tokenize</span><span class="w"> </span><span class="kn">import</span> <span class="n">get_tokenizer</span><span class="p">,</span> <span class="n">HTMLChunker</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tknzr</span> <span class="o">=</span> <span class="n">get_tokenizer</span><span class="p">(</span><span class="s2">&quot;en_US&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">w</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">tknzr</span><span class="p">(</span><span class="s2">&quot;this is &lt;span class=&#39;important&#39;&gt;really important&lt;/span&gt; text&quot;</span><span class="p">)]</span>
<span class="go">[(&#39;this&#39;, 0), (&#39;is&#39;, 5), (&#39;span&#39;, 9), (&#39;class&#39;, 14), (&#39;important&#39;, 21), (&#39;really&#39;, 32), (&#39;important&#39;, 39), (&#39;span&#39;, 50), (&#39;text&#39;, 56)]</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tknzr</span> <span class="o">=</span> <span class="n">get_tokenizer</span><span class="p">(</span><span class="s2">&quot;en_US&quot;</span><span class="p">,</span><span class="n">chunkers</span><span class="o">=</span><span class="p">(</span><span class="n">HTMLChunker</span><span class="p">,))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">w</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">tknzr</span><span class="p">(</span><span class="s2">&quot;this is &lt;span class=&#39;important&#39;&gt;really important&lt;/span&gt; text&quot;</span><span class="p">)]</span>
<span class="go">[(&#39;this&#39;, 0), (&#39;is&#39;, 5), (&#39;really&#39;, 32), (&#39;important&#39;, 39), (&#39;text&#39;, 56)]</span>
</pre></div>
</div>
<p>When the <a class="reference internal" href="api/enchant.tokenize.html#enchant.tokenize.HTMLChunker" title="enchant.tokenize.HTMLChunker"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTMLChunker</span></code></a> is applied to the tokenizer, the &lt;span&gt; tag and its contents are removed from the list of words.</p>
<p>Currently the only implemented chunker is <a class="reference internal" href="api/enchant.tokenize.html#enchant.tokenize.HTMLChunker" title="enchant.tokenize.HTMLChunker"><code class="xref py py-class docutils literal notranslate"><span class="pre">HTMLChunker</span></code></a>. A chunker for LaTeX documents is in the works.</p>
</section>
<section id="filters">
<h4>Filters<a class="headerlink" href="#filters" title="Link to this heading"></a></h4>
<p>In many applications, it is common for spellchecking to ignore words that have a certain form. For example, when spellchecking an email it is customary to ignore email addresses and URLs. This can be achieved by augmenting the tokenization process with filters.</p>
<p>A filter is simply a wrapper around a tokenizer that can (1) drop certain words from the stream, and (2) further split words into sub-tokens. They are typically used by passing a list of filters to the function <a class="reference internal" href="api/enchant.tokenize.html#enchant.tokenize.get_tokenizer" title="enchant.tokenize.get_tokenizer"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_tokenizer()</span></code></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">enchant.tokenize</span><span class="w"> </span><span class="kn">import</span> <span class="n">get_tokenizer</span><span class="p">,</span> <span class="n">EmailFilter</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tknzr</span> <span class="o">=</span> <span class="n">get_tokenizer</span><span class="p">(</span><span class="s2">&quot;en_US&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">w</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">tknzr</span><span class="p">(</span><span class="s2">&quot;send an email to fake@example.com please&quot;</span><span class="p">)]</span>
<span class="go">[(&#39;send&#39;, 0), (&#39;an&#39;, 5), (&#39;email&#39;, 8), (&#39;to&#39;, 14), (&#39;fake@example.com&#39;, 17), (&#39;please&#39;, 34)]</span>
<span class="gp">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tknzr</span> <span class="o">=</span> <span class="n">get_tokenizer</span><span class="p">(</span><span class="s2">&quot;en_US&quot;</span><span class="p">,</span> <span class="n">filters</span><span class="o">=</span><span class="p">[</span><span class="n">EmailFilter</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">[</span><span class="n">w</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">tknzr</span><span class="p">(</span><span class="s2">&quot;send an email to fake@example.com please&quot;</span><span class="p">)]</span>
<span class="go">[(&#39;send&#39;, 0), (&#39;an&#39;, 5), (&#39;email&#39;, 8), (&#39;to&#39;, 14), (&#39;please&#39;, 34)]</span>
</pre></div>
</div>
<p>When the <a class="reference internal" href="api/enchant.tokenize.html#enchant.tokenize.EmailFilter" title="enchant.tokenize.EmailFilter"><code class="xref py py-class docutils literal notranslate"><span class="pre">EmailFilter</span></code></a> is applied to the tokenizer, the email address is removed from the list of words.</p>
<p>Currently implemented filters are <a class="reference internal" href="api/enchant.tokenize.html#enchant.tokenize.EmailFilter" title="enchant.tokenize.EmailFilter"><code class="xref py py-class docutils literal notranslate"><span class="pre">EmailFilter</span></code></a>, <a class="reference internal" href="api/enchant.tokenize.html#enchant.tokenize.URLFilter" title="enchant.tokenize.URLFilter"><code class="xref py py-class docutils literal notranslate"><span class="pre">URLFilter</span></code></a> and <a class="reference internal" href="api/enchant.tokenize.html#enchant.tokenize.WikiWordFilter" title="enchant.tokenize.WikiWordFilter"><code class="xref py py-class docutils literal notranslate"><span class="pre">WikiWordFilter</span></code></a>.</p>
</section>
</section>
</section>
<section id="advanced-pyenchant-usage">
<h2>Advanced PyEnchant Usage<a class="headerlink" href="#advanced-pyenchant-usage" title="Link to this heading"></a></h2>
<section id="providers">
<h3>Providers<a class="headerlink" href="#providers" title="Link to this heading"></a></h3>
<p>The underlying programming model provided by the Enchant library is based on the notion of Providers. A provider is a piece of code that provides spell-checking services which Enchant can use to perform its work. Different providers exist for performing spellchecking using different frameworks - for example there is an aspell provider and a MySpell provider.</p>
<p>In this way, enchant forms a “wrapper” around existing spellchecking tools in order to provide a common programming interface.</p>
<p>The provider which is managing a particular <a class="reference internal" href="api/enchant.html#enchant.Dict" title="enchant.Dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">Dict</span></code></a> object can be determined by accessing its provider attribute. This is a <a class="reference internal" href="api/enchant.html#enchant.ProviderDesc" title="enchant.ProviderDesc"><code class="xref py py-class docutils literal notranslate"><span class="pre">ProviderDesc</span></code></a> object with the properties <code class="xref py py-attr docutils literal notranslate"><span class="pre">name</span></code>, <code class="xref py py-attr docutils literal notranslate"><span class="pre">desc</span></code> and <code class="xref py py-attr docutils literal notranslate"><span class="pre">file</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">enchant</span><span class="o">.</span><span class="n">Dict</span><span class="p">(</span><span class="s2">&quot;en_US&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="o">.</span><span class="n">provider</span> <span class="o">&lt;</span><span class="n">Enchant</span><span class="p">:</span> <span class="n">Aspell</span> <span class="n">Provider</span><span class="o">&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="o">.</span><span class="n">provider</span><span class="o">.</span><span class="n">name</span>
<span class="go">u&#39;aspell&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="o">.</span><span class="n">provider</span><span class="o">.</span><span class="n">desc</span>
<span class="go">u&#39;Aspell Provider&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="o">.</span><span class="n">provider</span><span class="o">.</span><span class="n">file</span>
<span class="go">u&#39;/usr/lib64/enchant/libenchant_aspell.so&#39;</span>
</pre></div>
</div>
</section>
<section id="brokers">
<h3>Brokers<a class="headerlink" href="#brokers" title="Link to this heading"></a></h3>
<p>The details of which provider is used to create a particular dictionary are managed by a <a class="reference internal" href="api/enchant.html#enchant.Broker" title="enchant.Broker"><code class="xref py py-class docutils literal notranslate"><span class="pre">Broker</span></code></a> object. Such objects have methods for creating dictionaries and checking whether a particular dictionary exists, as shown in the example below:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">enchant</span><span class="o">.</span><span class="n">Broker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span>
<span class="go">&lt;enchant.Broker object at 0x2aaaabdff810&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">dict_exists</span><span class="p">(</span><span class="s2">&quot;en_US&quot;</span><span class="p">)</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">dict_exists</span><span class="p">(</span><span class="s2">&quot;fake&quot;</span><span class="p">)</span>
<span class="go">False</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">list_languages</span><span class="p">()</span>
<span class="go">[&#39;en&#39;, &#39;en_CA&#39;, &#39;en_GB&#39;, &#39;en_US&#39;, &#39;eo&#39;, &#39;fr&#39;, &#39;fr_CH&#39;, &#39;fr_FR&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">request_dict</span><span class="p">(</span><span class="s2">&quot;en_US&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span>
<span class="go">&lt;enchant.Dict object at 0x2aaaabdff8d0&gt;</span>
</pre></div>
</div>
<p>Brokers also have the method <a class="reference internal" href="api/enchant.html#enchant.Broker.describe" title="enchant.Broker.describe"><code class="xref py py-meth docutils literal notranslate"><span class="pre">describe()</span></code></a> which determines which providers are available, and the method <a class="reference internal" href="api/enchant.html#enchant.Broker.list_dicts" title="enchant.Broker.list_dicts"><code class="xref py py-meth docutils literal notranslate"><span class="pre">list_dicts()</span></code></a> which lists the dictionaries available through each provider:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">enchant</span><span class="o">.</span><span class="n">Broker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">describe</span><span class="p">()</span>
<span class="go">[&lt;Enchant: Aspell Provider&gt;, &lt;Enchant: Myspell Provider&gt;, &lt;Enchant: Ispell Provider&gt;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">list_dicts</span><span class="p">()</span>
<span class="go">[(&#39;en&#39;, &lt;Enchant: Aspell Provider&gt;), (&#39;en_CA&#39;, &lt;Enchant: Aspell Provider&gt;), (&#39;en_GB&#39;, &lt;Enchant: Aspell Provider&gt;), (&#39;en_US&#39;, &lt;Enchant: Aspell Provider&gt;), (&#39;eo&#39;, &lt;Enchant: Aspell Provider&gt;), (&#39;fr&#39;, &lt;Enchant: Aspell Provider&gt;), (&#39;fr_CH&#39;, &lt;Enchant: Aspell Provider&gt;), (&#39;fr_FR&#39;, &lt;Enchant: Aspell Provider&gt;)]</span>
</pre></div>
</div>
<section id="the-default-broker">
<h4>The Default Broker<a class="headerlink" href="#the-default-broker" title="Link to this heading"></a></h4>
<p>In normal use, the functionality provided by brokers is not useful to the programmer. To make the programmer’s job easier, PyEnchant creates a default <a class="reference internal" href="api/enchant.html#enchant.Broker" title="enchant.Broker"><code class="xref py py-class docutils literal notranslate"><span class="pre">Broker</span></code></a> object and uses it whenever one is not explicitly given. For example, the default broker is used when creating dictionary objects directly. This object is available as <code class="xref py py-data docutils literal notranslate"><span class="pre">enchant._broker</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">enchant</span><span class="o">.</span><span class="n">_broker</span>
<span class="go">&lt;enchant.Broker object at 0x2aaaabdff590&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span> <span class="o">=</span> <span class="n">enchant</span><span class="o">.</span><span class="n">Dict</span><span class="p">(</span><span class="s2">&quot;en_US&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">d</span><span class="o">.</span><span class="n">_broker</span>
<span class="go">&lt;enchant.Broker object at 0x2aaaabdff590&gt;</span>
</pre></div>
</div>
<p>You may have noticed that the top-level functions provided by the enchant module (such as <a class="reference internal" href="api/enchant.html#enchant.request_dict" title="enchant.request_dict"><code class="xref py py-func docutils literal notranslate"><span class="pre">request_dict()</span></code></a>, <a class="reference internal" href="api/enchant.html#enchant.dict_exists" title="enchant.dict_exists"><code class="xref py py-func docutils literal notranslate"><span class="pre">dict_exists()</span></code></a> and <a class="reference internal" href="api/enchant.html#enchant.list_languages" title="enchant.list_languages"><code class="xref py py-func docutils literal notranslate"><span class="pre">list_languages()</span></code></a>) match the methods provided by the <a class="reference internal" href="api/enchant.html#enchant.Broker" title="enchant.Broker"><code class="xref py py-class docutils literal notranslate"><span class="pre">Broker</span></code></a> class. These functions are in fact the instance methods of the default <a class="reference internal" href="api/enchant.html#enchant.Broker" title="enchant.Broker"><code class="xref py py-class docutils literal notranslate"><span class="pre">Broker</span></code></a> object:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">enchant</span><span class="o">.</span><span class="n">_broker</span>
<span class="go">&lt;enchant.Broker object at 0x2aaaabdff590&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">enchant</span><span class="o">.</span><span class="n">request_dict</span><span class="o">.</span><span class="n">im_self</span>
<span class="go">&lt;enchant.Broker object at 0x2aaaabdff590&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">enchant</span><span class="o">.</span><span class="n">dict_exists</span><span class="o">.</span><span class="n">im_self</span>
<span class="go">&lt;enchant.Broker object at 0x2aaaabdff590&gt;</span>
</pre></div>
</div>
</section>
<section id="provider-ordering">
<span id="id1"></span><h4>Provider Ordering<a class="headerlink" href="#provider-ordering" title="Link to this heading"></a></h4>
<p>Which provider is used for which language is determined by the provider ordering of the <a class="reference internal" href="api/enchant.html#enchant.Broker" title="enchant.Broker"><code class="xref py py-class docutils literal notranslate"><span class="pre">Broker</span></code></a>. This can be altered using the method <a class="reference internal" href="api/enchant.html#enchant.Broker.set_ordering" title="enchant.Broker.set_ordering"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_ordering()</span></code></a>. This method accepts a language tag and a comma-separated list of provider names in the order that they should be checked. A language tag of “*” means that the ordering should be the default for all languages where an explicit ordering has not been given.</p>
<p>The following example states that for American English the MySpell provider should be tried first, followed by the aspell provider. For all other languages, the ordering is reversed:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">enchant</span><span class="o">.</span><span class="n">Broker</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">set_ordering</span><span class="p">(</span><span class="s2">&quot;en_US&quot;</span><span class="p">,</span><span class="s2">&quot;myspell,aspell&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">set_ordering</span><span class="p">(</span><span class="s2">&quot;*&quot;</span><span class="p">,</span><span class="s2">&quot;aspell,myspell&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">request_dict</span><span class="p">(</span><span class="s2">&quot;en_US&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">provider</span>
<span class="go">&lt;Enchant: Myspell Provider&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span><span class="o">.</span><span class="n">request_dict</span><span class="p">(</span><span class="s2">&quot;en_GB&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">provider</span>
<span class="go">&lt;Enchant: Aspell Provider&gt;</span>
</pre></div>
</div>
<p>The user can also set their preferred ordering using enchant configuration files. For this reason, application programmers are discouraged from explicitly setting an ordering unless there is a compelling reason to do so.</p>
</section>
</section>
<section id="extending-enchant-tokenize">
<h3>Extending enchant.tokenize<a class="headerlink" href="#extending-enchant-tokenize" title="Link to this heading"></a></h3>
<p>As explained above, the module <a class="reference internal" href="api/enchant.tokenize.html#module-enchant.tokenize" title="enchant.tokenize"><code class="xref py py-mod docutils literal notranslate"><span class="pre">enchant.tokenize</span></code></a> provides the ability to split text into its component words. The current implementation is based only on the rules for the English language, and so might not be completely suitable for your language of choice. Fortunately, it is straightforward to extend the functionality of this module.</p>
<p>To implement a new tokenization routine for the language <cite>TAG</cite>, simply create a class/function <cite>tokenize</cite> within the module <cite>enchant.tokenize.&lt;TAG&gt;</cite>. This function will automatically be detected by the module’s function <a class="reference internal" href="api/enchant.tokenize.html#enchant.tokenize.get_tokenizer" title="enchant.tokenize.get_tokenizer"><code class="xref py py-func docutils literal notranslate"><span class="pre">get_tokenizer()</span></code></a> and used when appropriate. The easiest way to accomplish this is to copy the module <code class="xref py py-mod docutils literal notranslate"><span class="pre">enchant.tokenize.en</span></code> and modify it to suit your needs.</p>
<p>The author would be very grateful for tokenization routines for languages other than English which can be incorporated back into the main PyEnchant distribution.</p>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="install.html" class="btn btn-neutral float-left" title="Installation" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="api/index.html" class="btn btn-neutral float-right" title="API Listing" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2011, Ryan Kelly.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>